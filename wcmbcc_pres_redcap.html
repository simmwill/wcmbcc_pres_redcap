<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>wcmbcc_pres_redcap.utf8</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.7/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/ninjutsu.css" rel="stylesheet" />
    <link rel="stylesheet" href="styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: center, middle, hide-count, title
background-image: url(images/files.jpeg)
background-size: cover

&lt;br&gt;
&lt;br&gt;

.content-box-title[
  ## Reproducible .cardinal[and] modifiable?
  #### PI-facing data repositories using REDCap API and R
]

&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;

.pull-right[
  .content-box-subtitle[
    &lt;small&gt;Will Simmons&lt;/small&gt; &lt;br&gt;
    &lt;small&gt;WCM Biostatistics Computing Club&lt;/small&gt; &lt;br&gt;
    &lt;small&gt;June 29, 2021&lt;/small&gt;
  ]
]

???

Hi everyone! Thanks for coming to our talks today - my name is Will, and I'm a Programmer Analyst in the 
Division of Biostatistics.

In this presentation, I'll talk a little about the concepts of reproducbility and modifiability, how those two
concepts are often in conflict when working with data, and how they *might* be reconciled in some very specific
but useful cases.

I'll discuss a tiny bit then go into a detailed example using R and the REDCap API.

---

class: center, middle

### &amp;nbsp;DATA&lt;sub&gt;1&lt;/sub&gt;&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .golden[**SCRIPT**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA&lt;sub&gt;2&lt;/sub&gt;

#### reproducible

&amp;nbsp;

???

So -- as people who work with data, we may think of reproducibility as a way to ensure our inputs yield
the same outputs via a series of defined actions, no matter the context or who's performing the actions.
Changes to these inputs are usually not permanent but rather preserved in a separate output.

In a simple case, this takes the form of input data being modified by a script, with the output saved as new data.

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è&amp;nbsp;&amp;nbsp;&amp;nbsp; .cardinal[**???**]&amp;nbsp;&amp;nbsp;&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

&amp;nbsp;

???

In most cases, modifiability conflicts with reproducibility. How can an output or process be reproducible 
if we can irreversibly modify it?

We've all come across common ways to modify data:

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .cardinal[**EXCEL**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

&amp;nbsp;

???

Maybe the most infamous is just directly editing an Excel spreadsheet.

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .cardinal[**EXCEL**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

üò± üò± üò±

???

At best, this can be frustrating; and, if we're not careful, we can end up with unseen errors in our analyses.

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .cardinal[**RE-DOWNLOAD**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

&amp;nbsp;

???

Another example that's just as common is redownloading a dataset from a regularly-updated backend source 
without preserving separate versions. This changes my source data without any proof that a change 
has occurred.

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .cardinal[**RE-DOWNLOAD**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

üò¨ üò¨ üò¨

???

Similarly, this can lead to code breaks, unexpected results, or even errors.

---

background-image: url(images/tug.jpeg)
background-size: cover

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
.pull-left[
  .text-shadow[*REPRODUCIBILITY*]
]

&lt;br&gt;&lt;br&gt;
.rightalign[
  .text-shadow[*MODIFIABILITY*]
]

&lt;br&gt;
.centeralign[
  .text-shadow[*YOUR DATA*]
]

.footnote[.white[Source: unsplash.com/@merittthomas]]

???

And so, it seems that we're at a standoff, right? With reproducibility and modifiability both 
tugging at our data.

However, I've been asking recently if there are scenarios where modifiability can be incorporated 
into reproducibility? Are there cases where modifiability is actually useful to research without
potentially harming it?

---

background-image: url(images/bffs_stick.jpeg)
background-size: cover

## .text-shadow[What if ... ?]

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
.pull-left[
.rightalign[
.text-shadow[*REPRODUCIBILITY*]
]
]

.pull-right[
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.text-shadow[*YOUR DATA*]
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
.text-shadow[*MODIFIABILITY*]
]

.footnote[Source: instagram.com/wat.ki]

???

So, I'm basically asking -- what if?

And while I don't think I've answered this question definitively for myself, my goal today is to 
explore a **very** tentative yes to both of these questions: yes, modifiability can be incorporated
into reproducible pipelines; and yes, it can even be useful and enhance them. 

---

class: center, middle

&lt;img src="images/db.png" width="50%" /&gt;&lt;img src="images/chart.png" width="50%" /&gt;

.footnote[Source: Shmidt Sergey, Egorova Valentina - Noun Project]

???

So -- here's a specific scenario I've been faced with several times. Data for a prospective study 
are located in at least two distinct places: a backend database, and in patient charts.

In other words, I needed both...

---

class: center, middle

### .golden[**Programmatically**] pulled (&amp; cleaned) data

&amp;nbsp;

### .magnolia[**Manually** abstracted data]

???

Programmatically pulled data, and...

---

class: center, middle

### .golden[**Programmatically**] pulled (&amp; cleaned) data

&amp;nbsp;

### .cardinal[**Manually**] abstracted data
  
???

Manually-abstracted data.

---
# Potential solutions:

&lt;br&gt;
&lt;ol&gt;

## .magnolia[&lt;li&gt;Change the **SQL** data itself]&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and send **CSV**]&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and set up **REDCap**]&lt;/li&gt;

&lt;/ol&gt;&amp;nbsp;

???

In my head, I had at least three solutions:

---

# Potential solutions:

&lt;br&gt;
&lt;ol&gt;

## &lt;li&gt;Change the .navy[**SQL**] data itself&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and send **CSV**]&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and set up **REDCap**]&lt;/li&gt;

&lt;/ol&gt;&amp;nbsp;

???

Potential approaches and issues/cautions with each:

  - PI could manually-abstract data to be housed in SQL backend
    - By far the most time-consuming and potentially unviable on the list
    - Good long-term, but many parties involved, and what if only needed for small subset of patients?
    - Also can't just change the source data whenever more data are needed

---

# Potential solutions:

&lt;br&gt;
&lt;ol&gt;

## &lt;li&gt;Change the .navy[**SQL**] data itself&lt;/li&gt;

## &lt;li&gt;Pull, clean, and send .forest[**CSV**]&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and set up **REDCap**]&lt;/li&gt;

&lt;/ol&gt;&amp;nbsp;

???

  - Pulling data from backend, then sending CSV to PI to manually abstract into
    - No opportunities for data validation
    - Potential for formatting errors, data deletion, etc.

---

# Potential solutions:

&lt;br&gt;

&lt;ol&gt;

## &lt;li&gt;Change the .navy[**SQL**] data itself&lt;/li&gt;

## &lt;li&gt;Pull, clean, and send .forest[**CSV**]&lt;/li&gt;

## &lt;li&gt;Pull, clean, and set up .cardinal[**REDCap**]&lt;/li&gt;

&lt;/ol&gt;&amp;nbsp;

???

  - R/REDCap API (w/ SQL frontend, but that's another talk)
    - Spoiler alert: this ended up being by solution, at least for now
    - I'm going to talk a little about why this seems like the best solution given the 
    circumstances, it's pros and cons, and work to improve this approach

---

class: center, middle

## Working with the REDCap API
### *via* .cardinal[.code[**REDCapR**]]

???

So, once I figured out I wanted to keep all of my work in R -- mainly because that's where I'm
most comfortable, but also to increase reproducibility -- I found REDCap's API.

And while there are some incredible packages out there -- httr, curl, and others -- REDCapR was an 
easy, out-of-the-box solution to linking R and REDCap via its API.

---

class: split-two

# Workflow


.pull-left[
&lt;ol style="line-height:62px;"&gt;
&lt;!-- &lt;h0 style="font-size:2.25rem"&gt; --&gt;
## &lt;li&gt; Pull&lt;/li&gt; 

## &lt;li&gt; Clean&lt;/li&gt; 

## &lt;li&gt; Push&lt;/li&gt; 

## &lt;li&gt; Abstract&lt;/li&gt; 
&lt;!-- &lt;/h0&gt; --&gt;
&lt;/ol&gt;.
]

--

.pull-right[
&lt;ul style="list-style-type:none; line-height:80px;"&gt;
&lt;li&gt;&lt;img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/rlogo.svg" height=65px style="margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcaprlogo.png" height=65px style="margin:-1px 5px 5px 20px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcap.png" height=65px style="margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
]

???

DRAFT

Brief outline of what I did with R-REDCap API:

  - Pull SQL data
  - Clean using R
  - Push using API (REDCapR) + helpers
  - Manual abstraction
    - Freeze a copy; create backup/sandbox REDCaps
    - Create workflows for further REDCap structural updates
    
... but what I'm really going to focus on today is ...

---

class: split-two

# Workflow


.pull-left[
&lt;ol style="line-height:62px;"&gt;
&lt;!-- &lt;h0 style="font-size:2.25rem"&gt; --&gt;
## .grey2[&lt;li&gt; Pull&lt;/li&gt;]

## .grey2[&lt;li&gt; Clean&lt;/li&gt;]

## &lt;li&gt; Push&lt;/li&gt; 

## .grey2[&lt;li&gt; Abstract&lt;/li&gt;]
&lt;!-- &lt;/h0&gt; --&gt;
&lt;/ol&gt;.
]

.pull-right[
&lt;ul style="list-style-type:none; line-height:80px;"&gt;
&lt;li&gt;&lt;img src="images/db.png" height=65px style="opacity:0.1; margin:10px 5px 5px 5px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/rlogo.svg" height=65px style="opacity:0.1; margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcaprlogo.png" height=65px style="margin:-1px 5px 5px 20px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcap.png" height=65px style="opacity:0.1; margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
]

???

... using the REDCapR package to ease your interactions with the REDCap API via R. This mostly entails this "push" step, but the "abstract" step will sneak in here a bit.

---

&lt;img src="images/redcapr-window.png"&gt;

???

So -- this is REDCapR. You can download it on CRAN

---

# Setup

## 1. Request .cardinal[REDCap API token] 

[static image or GIF of the API request process on a REDCap repository]

Store your token in secure spot accessible by .code[R] (e.g. using .code[keyring]).

???

Now, REDCapR requires a tiny bit of setup as an interface between R and REDCap

After setting up a REDCap database, you'll need to request an API token, which usually doesn't take more than a day to be administered.

Existing questions:

  - Do all phyiscians/PIs have access to REDCap? How would they get it if not?
  - 

---

# Setup

## 2. Ensure .golden[read/write] privileges

[static image or GIF of the User Rights portal on a REDCap repository]

API privileges should include **API Export** and **API Import/Update**.

---

# The Basics

### Pulling data from an existing .cardinal[REDCap]


```r
# setup ------------------------------------------------------------

library(REDCapR)

uri &lt;- "https://redcap.ctsc.weill.cornell.edu/redcap_protocols/api/"
token &lt;- "9A81268476645C4E5F03428B8AC3AA7B"  # not real
```

---

# The Basics

### Pulling data from an existing .cardinal[REDCap]


```r
# setup ------------------------------------------------------------

library(REDCapR)

uri &lt;- "https://redcap.ctsc.weill.cornell.edu/redcap_protocols/api/"
token &lt;- "9A81268476645C4E5F03428B8AC3AA7B"  # not real

# pull -------------------------------------------------------------

pull &lt;- `redcap_read`(redcap_uri = uri,
                    token = token)

data &lt;- pull$data
```

---

# The Basics

### Pushing data to .cardinal[REDCap]

Step 1: Defining your data dictionary

???

[not sure how in-the-weeds I should get here]
Concepts:
   - dictionary format
   - wdict()?
   - development vs. production
   - design via REDCap IDE
   
---

# The Basics

### Pushing data to .cardinal[REDCap]

Step 2: Exporting a dataframe 


```r
 `redcap_write`(ds_to_write = test_data,
              redcap_uri = uri,
              token = token)
```


---

???

DRAFT

About REDCap API, REDCapR, and other solutions

  - Allows backend R pipeline feeding frontend REDCap (manually-abstractable)
  - (Also reproducible SQL pipeline from SQL to R (more on that in another presentation, maybe!))
  - Pros of REDCap:
    - If data simply cannot be programmatically created (complex, unwieldy, etc.) - individuals may choose to manually abstract
    - Easy-to-use, already-available platform that many PIs are familiar with (vs. SQL)
  - Cons of REDCap, esp. with using API:
    - For safety, need to ensure robust systems for data backup (not default/built in, but not terribly difficult)

---

???

DRAFT - probably near end

(My) best practices

  - Test REDCap repositories (can set up via request to REDCap Admin)
  - Automatic backups using cron
  - Helper functions
    - Metadata writing
    - Safe backup and export  
       - R: functions 
       - REDCap: limiting access (mine or PI's) to read-only











---
class: center

tl;dr
&lt;br&gt;&lt;br&gt;&lt;br&gt;
# MODIFIABILITY CAN BE USEFUL!

--

### *. . . in select circumstances*

--

### *. . . with proper precautions*


??? 

Summary slide

---

???

Outline:
  - Scenarios where modifiability can be **carefully** explored
  - Scenarios where modifiability is NOT okay (from irresponsible to malicious/misleading)
  - One solution: REDCapR API
    - Allows backend R pipeline feeding frontend REDCap (manually-abstractable)
    - (Also reproducible SQL pipeline from SQL to R (more on that in another presentation, maybe!))
    - Pros:
      - If data simply cannot be programmatically created (complex, unwieldy, etc.) - individuals may choose to manually abstract
      - Easy-to-use, already-available platform that many PIs are familiar with (vs. SQL)
    - Cons:
      - For safety, need to ensure robust systems for data backup (not default/built in, but not terribly difficult)
  - Things I've incorporated on top of REDCap API
    - Test REDCap repositories (can set up via request to REDCap Admin)
    - Automatic backups using cron
    - Helper functions
      - Metadata writing
      - Safe backup and export  
         - R: functions 
         - REDCap: limiting access (mine or PI's) to read-only
         
---

Other topics
  - REDCap's API Playground (screenshot of window) - gives R code to interact with API

---

class: center

.pull-left[
  ## Reproducible:
  
  .leftalign[
  
- Bullet 1 about reproducibility

- Another thing about reproducibility ü§†

- Ok, **one** last thing!
    
  ]
  
]

--

.pull-right[
  ## Modifiable:
  
  .leftalign[
  
- First things first about modifying data

- It's not good üò¢

- But sometimes it's necessary!

  ]
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"countIncrementalSlides": false,
"highlightStyle": "github",
"highlightLines": true,
"highlightSpans": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
