<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>wcmbcc_pres_redcap.utf8</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.7/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/ninjutsu.css" rel="stylesheet" />
    <link rel="stylesheet" href="styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: center, middle, hide-count, title
background-image: url(images/files.jpeg)
background-size: cover

&lt;br&gt;
&lt;br&gt;

.content-box-title[
  ## Reproducible .cardinal[and] modifiable?
  #### PI-facing data repositories using REDCap API and R
]

&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;

.pull-right[
  .content-box-subtitle[
    &lt;small&gt;Will Simmons&lt;/small&gt; &lt;br&gt;
    &lt;small&gt;WCM Biostatistics Computing Club&lt;/small&gt; &lt;br&gt;
    &lt;small&gt;June 29, 2021&lt;/small&gt;
  ]
]

???

Hi everyone! Thanks for coming to our talks today - my name is Will, and I'm a Programmer Analyst in the 
Division of Biostatistics.

In this presentation, I'll talk a little about the concepts of reproducbility and modifiability, how those two
concepts are often in conflict when working with data, and how they *might* be reconciled in some very specific
but useful cases.

Then, I'll go into a detailed example using R and the REDCap API.

---

class: center, middle

### &amp;nbsp;DATA&lt;sub&gt;1&lt;/sub&gt;&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .golden[**SCRIPT**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA&lt;sub&gt;2&lt;/sub&gt;

#### reproducible

&amp;nbsp;

???

So -- as people who work with data, we may think of reproducibility as a way to ensure our inputs yield
the same outputs via a series of defined actions, no matter the context or who's performing the actions.
Changes to these inputs are usually not permanent but rather preserved in a separate output.

In a simple case, this takes the form of input data being modified by a script, with the output saved as new data.

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è&amp;nbsp;&amp;nbsp;&amp;nbsp; .cardinal[**???**]&amp;nbsp;&amp;nbsp;&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

&amp;nbsp;

???

In most cases, modifiability conflicts with reproducibility. How can an output or process be reproducible 
if we can irreversibly modify it?

We've all come across common ways to modify data:

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .cardinal[**EXCEL**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

&amp;nbsp;

???

Maybe the most infamous is just directly editing an Excel spreadsheet.

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .cardinal[**EXCEL**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

üò± üò± üò±

???

At best, this can be frustrating; and, if we're not careful, we can end up with unpredicted changes to or errors in our analyses.

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .cardinal[**RE-DOWNLOAD**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

&amp;nbsp;

???

Another example that's just as common is redownloading a dataset from a regularly-updated backend source 
without preserving separate versions. This changes my source data without any proof that a change 
has occurred.

---

class: center, middle

### DATA&amp;nbsp; ‚û°Ô∏è &amp;nbsp; .cardinal[**RE-DOWNLOAD**]&amp;nbsp; ‚û°Ô∏è &amp;nbsp; DATA

#### modifiable

üò¨ üò¨ üò¨

???

Similarly, this can lead to code breaks, unexpected results, or even incorrect analyses.

---

background-image: url(images/tug.jpeg)
background-size: cover

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
.pull-left[
  .text-shadow[*REPRODUCIBILITY*]
]

&lt;br&gt;&lt;br&gt;
.rightalign[
  .text-shadow[*MODIFIABILITY*]
]

&lt;br&gt;
.centeralign[
  .text-shadow[*YOUR DATA*]
]

.footnote[.white[Source: unsplash.com/@merittthomas]]

???

And so, it seems that we're at a standoff, right? With reproducibility and modifiability both 
tugging at our data.

However, I've been asking recently if there are scenarios where modifiability can be incorporated 
into reproducibility? Are there cases where, if I were careful, modifiability could be useful to research?

---

background-image: url(images/bffs_stick.jpeg)
background-size: cover

## .text-shadow[What if ... ?]

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
.pull-left[
.rightalign[
.text-shadow[*REPRODUCIBILITY*]
]
]

.pull-right[
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.text-shadow[*YOUR DATA*]
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
.text-shadow[*MODIFIABILITY*]
]

.footnote[Source: instagram.com/wat.ki]

???

So, I'm basically asking -- what if?

And while I don't think I've answered this question definitively for myself, my goal today is to 
explore a **very** tentative yes to both of these questions: yes, modifiability can be incorporated
into reproducible pipelines; and yes, it can even be useful and enhance them. 

---

class: center, middle

&lt;img src="images/db.png" width="50%" /&gt;&lt;img src="images/chart.png" width="50%" /&gt;

.footnote[Source: Shmidt Sergey, Egorova Valentina - Noun Project]

???

So -- here's a specific scenario I've faced several times. Data for a planed study 
are located in at least two distinct places: a backend database, and in patient charts.

In other words, I need both...

---

class: center, middle

### .golden[**Programmatically**] pulled (&amp; cleaned) data

&amp;nbsp;

### .magnolia[**Manually** abstracted data]

???

Programmatically pulled data, and...

---

class: center, middle

### .golden[**Programmatically**] pulled (&amp; cleaned) data

&amp;nbsp;

### .cardinal[**Manually**] abstracted data
  
???

Manually-abstracted data.
---

# Potential solutions

&lt;br&gt;
&lt;ol&gt;

## .magnolia[&lt;li&gt;Change the **SQL** data itself]&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and send **CSV**]&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and set up **REDCap**]&lt;/li&gt;

&lt;/ol&gt;&amp;nbsp;

???

In my head, I had at least three solutions:

---

# Potential solutions

&lt;br&gt;
&lt;ol&gt;

## &lt;li&gt;Change the .navy[**SQL**] data itself&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and send **CSV**]&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and set up **REDCap**]&lt;/li&gt;

&lt;/ol&gt;&amp;nbsp;

???

Potential approaches and issues/cautions with each:

  - PI could manually-abstract data to be housed in SQL backend
    - By far the most time-consuming and potentially unviable on the list
    - Good long-term, but many parties involved, and what if only needed for small subset of patients?
    - Also can't just change the source data whenever more data are needed

---

# Potential solutions

&lt;br&gt;
&lt;ol&gt;

## &lt;li&gt;Change the .navy[**SQL**] data itself&lt;/li&gt;

## &lt;li&gt;Pull, clean, and send .forest[**CSV**]&lt;/li&gt;

## .magnolia[&lt;li&gt;Pull, clean, and set up **REDCap**]&lt;/li&gt;

&lt;/ol&gt;&amp;nbsp;

???

  - Pulling data from backend, then sending CSV to PI to manually abstract into
    - I've done this before, and it worked ... with some caveats
    - Fewer opportunities for data validation
    - Potential for formatting errors, data deletion, etc.

---

# Potential solutions

&lt;br&gt;

&lt;ol&gt;

## &lt;li&gt;Change the .navy[**SQL**] data itself&lt;/li&gt;

## &lt;li&gt;Pull, clean, and send .forest[**CSV**]&lt;/li&gt;

## &lt;li&gt;Pull, clean, and set up .cardinal[**REDCap**]&lt;/li&gt;

&lt;/ol&gt;&amp;nbsp;

*among other solutions...*

???

  - R/REDCap API 
    - Spoiler alert: this ended up being by solution, at least for now
    - Instead of hashing it out now, I'm going to spend most of this presentation explaining:
      - why this seems like the best solution given the circumstances
      - Its pros and cons
      - And best practices for using this approach in research with clinical data

---

class: center, middle

## Working with the REDCap API
### *via* .cardinal[.code[**REDCapR**]]

???

One of the main reasons I chose this approach was that I could keep all of my work in R. I didn't need to do as much switching between the REDCap online interface, because everything -- from pulling the SQL data to cleaning and pushing data to REDCap -- were contained in R scripts.

And while there are some incredible packages out there to deal with APIs in R -- httr, curl, and others -- REDCapR was an easy, out-of-the-box solution to linking R and REDCap via the API.

---

class: split-two

# Workflow


.pull-left[
&lt;ol style="line-height:62px;"&gt;

## &lt;li&gt; Pull&lt;/li&gt; 

## &lt;li&gt; Clean&lt;/li&gt; 

## &lt;li&gt; Push&lt;/li&gt; 

## &lt;li&gt; Abstract&lt;/li&gt; 

&lt;/ol&gt;.
]

--

.pull-right[
&lt;ul style="list-style-type:none; line-height:80px;"&gt;
&lt;li&gt;&lt;img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/rlogo.svg" height=65px style="opacity:0; margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcaprlogo.png" height=65px style="opacity:0; margin:-1px 5px 5px 20px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcap.png" height=65px style="opacity:0; margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;/ul&gt;
]

???

So, as I mentioned, my workflow was basically this:

  - Pull data from a SQL backend (often integrating other sources, as well)
    - I usually use packages like DBI, dbmi, and dbplyr here, but I could give an entire separate talk on those

---

class: split-two

# Workflow


.pull-left[
&lt;ol style="line-height:62px;"&gt;

## &lt;li&gt; Pull&lt;/li&gt; 

## &lt;li&gt; Clean&lt;/li&gt; 

## &lt;li&gt; Push&lt;/li&gt; 

## &lt;li&gt; Abstract&lt;/li&gt; 

&lt;/ol&gt;.
]

.pull-right[
&lt;ul style="list-style-type:none; line-height:80px;"&gt;
&lt;li&gt;&lt;img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/rlogo.svg" height=65px style="margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcaprlogo.png" height=65px style="opacity:0; margin:-1px 5px 5px 20px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcap.png" height=65px style="opacity:0; margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;/ul&gt;
]

???

  - Clean the data in a series of R scripts

---

class: split-two

# Workflow


.pull-left[
&lt;ol style="line-height:62px;"&gt;

## &lt;li&gt; Pull&lt;/li&gt; 

## &lt;li&gt; Clean&lt;/li&gt; 

## &lt;li&gt; Push&lt;/li&gt; 

## &lt;li&gt; Abstract&lt;/li&gt; 

&lt;/ol&gt;.
]

.pull-right[
&lt;ul style="list-style-type:none; line-height:80px;"&gt;
&lt;li&gt;&lt;img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/rlogo.svg" height=65px style="margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcaprlogo.png" height=65px style="margin:-1px 5px 5px 20px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcap.png" height=65px style="opacity:0; margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;/ul&gt;
]

???

  - Push the data to REDCap using REDCapR

---

class: split-two

# Workflow


.pull-left[
&lt;ol style="line-height:62px;"&gt;

## &lt;li&gt; Pull&lt;/li&gt; 

## &lt;li&gt; Clean&lt;/li&gt; 

## &lt;li&gt; Push&lt;/li&gt; 

## &lt;li&gt; Abstract&lt;/li&gt; 

&lt;/ol&gt;.
]

.pull-right[
&lt;ul style="list-style-type:none; line-height:80px;"&gt;
&lt;li&gt;&lt;img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/rlogo.svg" height=65px style="margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcaprlogo.png" height=65px style="margin:-1px 5px 5px 20px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcap.png" height=65px style="margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;/ul&gt;
]

???

  - And then allow the PI to manually-abstract whatever data needs to be added via the REDCap online interface

... but what I'm really going to focus on today is ...

---

class: split-two

# Workflow


.pull-left[
&lt;ol style="line-height:62px;"&gt;

## .grey2[&lt;li&gt; Pull&lt;/li&gt;]

## .grey2[&lt;li&gt; Clean&lt;/li&gt;]

## &lt;li&gt; Push&lt;/li&gt; 

## .grey2[&lt;li&gt; Abstract&lt;/li&gt;]

&lt;/ol&gt;.
]

.pull-right[
&lt;ul style="list-style-type:none; line-height:80px;"&gt;
&lt;li&gt;&lt;img src="images/db.png" height=65px style="opacity:0.1; margin:10px 5px 5px 5px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/rlogo.svg" height=65px style="opacity:0.1; margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcaprlogo.png" height=65px style="margin:-1px 5px 5px 20px"&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src="images/redcap.png" height=65px style="opacity:0.1; margin:-1px 5px 5px 15px"&gt;&lt;/li&gt;
]

???

... using the REDCapR package to ease your interactions with the REDCap API via R. This mostly entails this "push" step, but the "abstract" step will sneak in here a bit.

---

&lt;img src="images/redcapr-window.png"&gt;

???

So -- this is REDCapR. You can download it on CRAN

---

# Setup

&lt;br&gt; 

## 1. Request a .cardinal[REDCap API token] 

&lt;br&gt;

Store your token in secure spot accessible by .code[R] (e.g. using .code[keyring]).

???

It requires a tiny bit of setup as an interface between R and REDCap.

I won't go through this in too much detail, since the purpose of this presentation is more to make you aware of these features, but I'll mention the steps briefly.

whether you're using a new or existing REDCap database, you'll need to request an API token, which usually doesn't take more than a day to be administered.

---

# Setup

&lt;br&gt; 
## 2. Ensure .golden[read/write] privileges

&lt;br&gt;

API privileges should include **API Export** and **API Import/Update**.

???

After you've been assigned a token, you'll also need to make sure you have the proper privileges on your REDCap repository. These user privileges are also useful for protecting your data from being accidentally edited by you or others.

---

# The Basics

### Get data from an existing .cardinal[REDCap]

--


```r
# setup ------------------------------------------------------------

library(REDCapR)

uri &lt;- "https://redcap.ctsc.weill.cornell.edu/redcap_protocols/api/"
token &lt;- "9A81268476645C4E5F03428B8AC3AA7B"  # not real; store elsewhere!
```

???

So - maybe the most useful thing that anyone can do, even if you're not going to program an entire REDCap database in R, is to pull data using the REDCapR package.

First, assign your uri (which should be the same across Cornell REDCap repos) and token. And again, I usually store my token in a secure spot, but I'm showing it here for illustration.

---

# The Basics

### Get data from an existing .cardinal[REDCap]


```r
# setup ------------------------------------------------------------

library(REDCapR)

uri &lt;- "https://redcap.ctsc.weill.cornell.edu/redcap_protocols/api/"
token &lt;- "9A81268476645C4E5F03428B8AC3AA7B"  # not real; store elsewhere!

# pull -------------------------------------------------------------

pull &lt;- `redcap_read`(redcap_uri = uri,
                    token = token)

data &lt;- pull$data
```

???

Next, you'll use REDCapR's redcap_read() function to pull data. It returns a variety of API-related data, but what we're really interested in is the repository data. You can pull that by subsetting the data element from the REDCap pull.

---

# The Basics

### Get **meta**data from an existing .cardinal[REDCap]

--


```r
# pull -------------------------------------------------------------

dict_pull &lt;- `redcap_metadata_read`(redcap_uri = uri,
                                  token = token)

dictionary &lt;- dict_pull$data
```

???

Metadata, which includes your data's dictionary, is also something useful you can pull from REDCap via the API. Just use the redcap_metadata_read function, from which you'll again subset the data element to get the dictionary. The dictionary is pulled as a dataframe that contains the field names, their types, and other useful info.

---

# The Basics

### Pushing things to .cardinal[REDCap]: your **metadata**

--


```r
# dictionary -------------------------------------------------------

 `redcap_metadata_write`(ds = dict,
                       redcap_uri = uri,
                       token = token)
```

???

Pushing data to REDCap via the API requires a little bit of learning, both about REDCap formats and using an API, neither of which I was familiar with. However, if this sounds like something that could be useful in your work, it could be worthwhile.

First, you'll need to define your data dictionary; I won't get too in the weeds here, but without a defined template for your data stored in REDCap, REDCap won't accept it. You can design the dictionary on the online REDCap interface or programmatically. If you'll be making lots of iterative changes or defining hundreds of variables, it might be worth doing programmatically.

You can do it programmatically using the redcap_metadata_write function. Your dictionary needs to be a specifically-formatted dataframe, but I won't cover the format in detail in this presentation.

---

# The Basics

### Pushing things to .cardinal[REDCap]: your **data**

--


```r
# data -------------------------------------------------------------

 `redcap_write`(ds_to_write = df,
              redcap_uri = uri,
              token = token)
```

???

Once you have a correctly-formatted dictionary in REDCap, you can push data to REDCap using the redcap_write function. I spend a lot of my time querying and cleaning data from SQL backends, and this function is incredibly useful to push data directly to REDCap repositories.

As with dictionaries, these dataframes need to be formatted specifically, especially if you're working in a REDCap project with longitudinal data. 

---

&lt;h1 style="margin: 60px 0 50px 0"&gt;
More Advanced
&lt;/h1&gt;

&lt;h3 style="margin: -10px 0 30px 0"&gt;
Updating existing data on .cardinal[REDCap]
&lt;/h3&gt;

???

A little more advanced is actually updating existing data on a REDCap repository. Let's say you're just pushing SQL data at this point -- no manual abstraction has occurred.  However, you realize the SQL data needs a few edits.

There are several ways to accomplish this. One way I've done it is:

--

&lt;ol&gt;
  &lt;li spacing="compact"&gt;&amp;ensp; Pull existing data&lt;/li&gt;


```r
old_data &lt;- `redcap_read`(uri, token)
```
???
  - Pull your existing data from REDCap, so that you have your current, correctly-formatted data to work from.

--
  &lt;li&gt;&amp;ensp; Modify data in R pipeline (save this code!)&lt;/li&gt;
  

```r
new_data &lt;- old_data %&gt;% 
  mutate(new_col = ...,                         # modify dictionary
         existing_col = f(existing_col)) %&gt;%    # no need
  add_row(...)                                  # no need
```
???
  - Modify your data using an R script. Be sure to save this code and incorporate it into your pipeline for reproducibility!
  
--
  &lt;li&gt;&amp;ensp; Push new data (and dictionary, if needed)
  

```r
 `redcap_write`(new_data, uri, token)
```
???
  - Then, push the edited data back to your REDCap. If you've added new columns, you may need to push a new dictionary before you push new data. With new rows and modifications to existing columns, you don't need to push a new dictionary.

---

# Even More Advanced...

### More .golden[API] stuff in R (.code[httr], .code[curl])

???

So, here's an even more advanced use-case if you really want to tinker with your REDCap database. You can do a lot of things with the REDCap API directly that REDCapR doesn't have functions for. 

--

```r
# project attributes -----------------------------------------------

formData &lt;- list("token" = token,
                  content = 'project',
                  format = 'csv',
                  returnFormat = 'json')
response &lt;- `httr::POST`(url, body = formData, encode = "form")
result &lt;- httr::content(response)
```

???

This code is shown as an example, but it pulls project attributes from REDCap, which is useful for seeing whether a project is longitudinal, when it was last updated, and so on. You can also edit these attributes via the API.

--

*REDCap's .cardinal[**API playground**] is helpful here!

???

REDCap has an API playground that will walk you through different API functions and the R code needed to accomplish them. R packages httr and curl are most commonly used to deal with APIs.

---

# Use-cases
&lt;br&gt;
???
So with all of this in mind, what are some uses cases here?
--

### Mix programmatic and .cardinal[abstracted] data
???
The first is what I've been primarily concerned with. A PI needs to combine data from a backend server with data that can only be manually-abstracted. Instead of playing the game where we send each other a million CSV files, this has increased reproducbility a hundredfold for those projects.
--

### Long-term .forest[data sharing] with a team
???
Perhaps a simpler use-case is long-term data sharing with a team of researchers. Especially during COVID, cohorts are being created and modified weekly; if these data are stored and updated in REDCap via a reproducible pipeline, it'll reduce the chance of merge errors -- and you'll have fewer dated (or indistinguishable) CSV files in your data folder.
--

### If nothing else: .golden[API] convenience functions!
???
And, if nothing else - use the API in your pipelines to pull and catalog data from your existing REDCap repositories! One neat trick is to designate which columns are PHI, then easily pull a deidentified dataset if needed.

---

# Limitations üò•
&lt;br&gt;
???
As I've mentioned, you have to take a lot of caution in using this approach. As such, there are some limitations here.
--

### Easy to .golden[mess things up]
???
First and most importantly, it's really easy to overwrite your REDCap, whether parts of it or the whole thing. I've started using cron to pull automatic data backups, and I've created functions to automatically save a backup anytime I update the REDCap, but it's still terrifing how easy it is to push a mistake and wipe your data.
--

### Pushed vs. .forest[abstracted] data
???
Secondly -- this is a pretty important note -- once someone starts manually abstracting into the REDCap frontend, you‚Äôre stuck with the source data you've pushed from the backend. In my experience, there was just no simple way to, let's say, refresh your SQL source data after manual abstractions have occurred, since there aren't advanced difftools and mergetools that would allow you to distinguish which edits came from where. Thus, if you pushed new SQL data from the backend, it would erase all frontend manual edits.
--

### Particular .navy[object formatting] for RC API
???
The formatting of data and metadata uploaded via REDCap's API can be somewhat tricky. The peculiarities seem trivial until you need to produce pipelines for hundreds of variables, so I just have to write, commment, and debug API code carefully.
--

### .cardinal[REDCap] dev vs. prod status
???
Lastly, REDCap distinguishes between projects in development vs. production status, with the main difference being that production status makes a project harder to edit. Some REDCapR functions are limited to development projects due to their destructive nature, such as changing the dictionary. However, if proper caution is taken, I think the benefits outweigh the risks.

---

# Best .golden[(?)] practices
&lt;br&gt;
???
So -- some of my best practices so far! The question mark is there because I have no idea what best practices actually look like here. This has been a very iterative process, and I look forward to someone telling me a better way to approach anything I'm doing here.
--

### REDCap user rights ‚úÖ
???
As I've mentioned before, use REDCap user rights to your advantage! I change these frequently to make sure my colleagues and I aren't accidentally changing the data at a critical stage of data abstraction. 
--

### Regular (automated!) **backups** üîÑ
???
Another thing I've found is that regular backups are GREAT, even if just for peace of mind. As I mentioned, I use cron on my MacBook to automatically run an R script that saves a backup of my REDCap repositories once a week. The repositories I currently work with are pretty small, but if you're looking at millions of rows, REDCap probably isn't the most efficient solution for you anyway.
--

### **Test**/**sandbox** REDCap repositories üë∑
???
Another in the peace-of-mind category is a test REDCap repository. Before I change the dictionary or push new data to a PI-facing REDCap, I'll copy the production REDCap to a test REDCap and implement my changes there. This is a good thing, because usually my changes somehow break the database. If you have an exising REDCap project, requesting another database for test purposes is easy and very highly recommended!
--

### Personal **helper** functions üß∞
???
Lastly, I know I'm speaking to the computing club when I say this -- create helper functions on top of packages like REDCapR! Something I've learned in every aspect of my programming, not just dealing with APIs, is that custom functions allow me to do less debugging and consider higher-level aspects of my projects and analyses. Time spent writing these functions pays off several fold. 

---
???

[some sort of slide that brings together the ideas of reproducibility and modifiability]

e.g. all of this has married the two ideas of repro and mod

I hope you've seen that mod from PI end of REDCap is useful, but using that as an excuse to abandon reproducibility isn't necessary

---
class: center

.cardinal[**tl;dr**]
&lt;br&gt;&lt;br&gt;&lt;br&gt;
# MODIFIABILITY CAN BE USEFUL!

--

### *. . . in some circumstances*

--

### *. . . with proper precautions*


???

Summary slide

---

class: center, middle

# üëã
# questions?

---

???

DRAFT

About REDCap API, REDCapR, and other solutions

  - Allows backend R pipeline feeding frontend REDCap (manually-abstractable)
  - (Also reproducible SQL pipeline from SQL to R (more on that in another presentation, maybe!))
  - Pros of REDCap:
    - If data simply cannot be programmatically created (complex, unwieldy, etc.) - individuals may choose to manually abstract
    - Easy-to-use, already-available platform that many PIs are familiar with (vs. SQL)
  - Cons of REDCap, esp. with using API:
    - For safety, need to ensure robust systems for data backup (not default/built in, but not terribly difficult)

---

???

DRAFT - probably near end

(My) best practices

  - Test REDCap repositories (can set up via request to REDCap Admin)
  - Automatic backups using cron
  - Helper functions
    - Metadata writing
    - Safe backup and export  
       - R: functions 
       - REDCap: limiting access (mine or PI's) to read-only













???

Outline:
  - Scenarios where modifiability can be **carefully** explored
  - Scenarios where modifiability is NOT okay (from irresponsible to malicious/misleading)
  - One solution: REDCapR API
    - Allows backend R pipeline feeding frontend REDCap (manually-abstractable)
    - (Also reproducible SQL pipeline from SQL to R (more on that in another presentation, maybe!))
    - Pros:
      - If data simply cannot be programmatically created (complex, unwieldy, etc.) - individuals may choose to manually abstract
      - Easy-to-use, already-available platform that many PIs are familiar with (vs. SQL)
    - Cons:
      - For safety, need to ensure robust systems for data backup (not default/built in, but not terribly difficult)
  - Things I've incorporated on top of REDCap API
    - Test REDCap repositories (can set up via request to REDCap Admin)
    - Automatic backups using cron
    - Helper functions
      - Metadata writing
      - Safe backup and export  
         - R: functions 
         - REDCap: limiting access (mine or PI's) to read-only
         
---
???
Other topics
  - REDCap's API Playground (screenshot of window) - gives R code to interact with API

---

class: center

.pull-left[
  ## Reproducible:
  
  .leftalign[
  
- Bullet 1 about reproducibility

- Another thing about reproducibility ü§†

- Ok, **one** last thing!
    
  ]
  
]

--

.pull-right[
  ## Modifiable:
  
  .leftalign[
  
- First things first about modifying data

- It's not good üò¢

- But sometimes it's necessary!

  ]
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"countIncrementalSlides": false,
"highlightStyle": "github",
"highlightLines": true,
"highlightSpans": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
