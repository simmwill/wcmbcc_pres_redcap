---
output:
  xaringan::moon_reader:
    css: ["styles.css", "ninjutsu"]
    seal: false
    lib_dir: libs
    nature:
      countIncrementalSlides: false
      highlightStyle: github
      highlightLines: true
      highlightSpans: true
---

```{r xaringan-extra-features, echo=FALSE}
xaringanExtra::use_tile_view()
xaringanExtra::use_search(show_icon = TRUE)
xaringanExtra::use_clipboard()
xaringanExtra::use_extra_styles(
  hover_code_line = TRUE
)
```

class: center, middle, hide-count, title
background-image: url(images/files.jpeg)
background-size: cover

<br>
<br>

.content-box-title[
  ## Reproducible .cardinal[and] modifiable?
  #### PI-facing data repositories using REDCap API and R
]

<br>
<br>
<br>
<br>
<br>
<br>
<br>

.pull-right[
  .content-box-subtitle[
    <small>Will Simmons</small> <br>
    <small>WCM Biostatistics Computing Club</small> <br>
    <small>June 29, 2021</small>
  ]
]

???

Hi everyone! Thanks for coming to our talks today - my name is Will, and I'm a Programmer Analyst in the 
Division of Biostatistics.

In this presentation, I'll talk a little about the concepts of reproducbility and modifiability, how those two
concepts are often in conflict when working with data, and how they *might* be reconciled in some very specific
but useful cases.

Then, I'll go into a detailed example using R and the REDCap API.

---

class: center, middle

### &nbsp;DATA<sub>1</sub>&nbsp; `r emo::ji("arrow_right")` &nbsp; .golden[**SCRIPT**]&nbsp; `r emo::ji("arrow_right")` &nbsp; DATA<sub>2</sub>

#### reproducible

&nbsp;

???

So -- as people who work with data, we may think of reproducibility as a way to ensure our inputs yield
the same outputs via a series of defined actions, no matter the context or who's performing the actions.
Changes to these inputs are usually not permanent but rather preserved in a separate output.

In a simple case, this takes the form of input data being modified by a script, with the output saved as new data.

---

class: center, middle

### DATA&nbsp; `r emo::ji("arrow_right")`&nbsp;&nbsp;&nbsp; .cardinal[**???**]&nbsp;&nbsp;&nbsp; `r emo::ji("arrow_right")` &nbsp; DATA

#### modifiable

&nbsp;

???

In most cases, modifiability conflicts with reproducibility. How can an output or process be reproducible 
if we can irreversibly modify it?

We've all come across common ways to modify data:

---

class: center, middle

### DATA&nbsp; `r emo::ji("arrow_right")` &nbsp; .cardinal[**EXCEL**]&nbsp; `r emo::ji("arrow_right")` &nbsp; DATA

#### modifiable

&nbsp;

???

Maybe the most infamous is just directly editing an Excel spreadsheet.

---

class: center, middle

### DATA&nbsp; `r emo::ji("arrow_right")` &nbsp; .cardinal[**EXCEL**]&nbsp; `r emo::ji("arrow_right")` &nbsp; DATA

#### modifiable

`r emo::ji("scream")` `r emo::ji("scream")` `r emo::ji("scream")`

???

At best, this can be frustrating; and, if we're not careful, we can end up with unpredicted changes or errors in our analyses.

---

class: center, middle

### DATA&nbsp; `r emo::ji("arrow_right")` &nbsp; .cardinal[**RE-DOWNLOAD**]&nbsp; `r emo::ji("arrow_right")` &nbsp; DATA

#### modifiable

&nbsp;

???

Another example that's just as common is redownloading a dataset from a regularly-updated backend source 
without preserving separate versions. This changes my source data without any proof that a change 
has occurred.

---

class: center, middle

### DATA&nbsp; `r emo::ji("arrow_right")` &nbsp; .cardinal[**RE-DOWNLOAD**]&nbsp; `r emo::ji("arrow_right")` &nbsp; DATA

#### modifiable

`r emo::ji("grimace")` `r emo::ji("grimace")` `r emo::ji("grimace")`

???

Similarly, this can lead to code breaks, unexpected results, or even incorrect analyses.

---

background-image: url(images/tug.jpeg)
background-size: cover

<br><br><br><br><br><br><br><br><br>
.pull-left[
  .text-shadow[*REPRODUCIBILITY*]
]

<br><br>
.rightalign[
  .text-shadow[*MODIFIABILITY*]
]

<br>
.centeralign[
  .text-shadow[*YOUR DATA*]
]

.footnote[.white[Source: unsplash.com/@merittthomas]]

???

And so, it seems that we're at a standoff, right? With reproducibility and modifiability both 
tugging at our data.

However, I've been asking recently if there are scenarios where modifiability can be incorporated 
into reproducibility? Are there cases where, if I were careful, modifiability could be useful to research?

---

background-image: url(images/bffs_stick.jpeg)
background-size: cover

## .text-shadow[What if ... ?]

<br><br><br><br><br>
.pull-left[
.rightalign[
.text-shadow[*REPRODUCIBILITY*]
]
]

.pull-right[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.text-shadow[*YOUR DATA*]
<br><br><br><br>
.text-shadow[*MODIFIABILITY*]
]

.footnote[Source: instagram.com/wat.ki]

???

So, I'm basically asking -- what if?

And while I don't think I've answered this question definitively for myself, my goal today is to 
explore a **very** tentative yes to both of these questions: yes, modifiability can be incorporated
into reproducible pipelines; and yes, it can even be useful and enhance them. 

---

class: center, middle

```{r, echo = FALSE, out.width="50%"}
knitr::include_graphics(c("images/db.png",
                          "images/chart.png")
)
```

.footnote[Source: Shmidt Sergey, Egorova Valentina - Noun Project]

???

So -- here's a specific scenario I've faced several times. Data for a planed study 
are located in at least two distinct places: a backend database, and in patient charts.

In other words, I need both...

---

class: center, middle

### .golden[**Programmatically**] pulled (& cleaned) data

&nbsp;

### .magnolia[**Manually** abstracted data]

???

Programmatically pulled data, and...

---

class: center, middle

### .golden[**Programmatically**] pulled (& cleaned) data

&nbsp;

### .cardinal[**Manually**] abstracted data
  
???

Manually-abstracted data.
---

# Potential solutions

<br>
<ol>

## .magnolia[<li>Change the **SQL** data itself]</li>

## .magnolia[<li>Pull, clean, and send **CSV**]</li>

## .magnolia[<li>Pull, clean, and set up **REDCap**]</li>

</ol>&nbsp;

???

In my head, I had at least three solutions:

---

# Potential solutions

<br>
<ol>

## <li>Change the .navy[**SQL**] data itself</li>

## .magnolia[<li>Pull, clean, and send **CSV**]</li>

## .magnolia[<li>Pull, clean, and set up **REDCap**]</li>

</ol>&nbsp;

???

Potential approaches and issues/cautions with each:

  - PI could manually-abstract data to be housed in SQL backend
    - By far the most time-consuming and potentially unviable on the list
    - Good long-term, but many parties involved, and what if only needed for small subset of patients?
    - Also can't just change the source data whenever more data are needed

---

# Potential solutions

<br>
<ol>

## <li>Change the .navy[**SQL**] data itself</li>

## <li>Pull, clean, and send .forest[**CSV**]</li>

## .magnolia[<li>Pull, clean, and set up **REDCap**]</li>

</ol>&nbsp;

???

  - Pulling data from backend, then sending CSV to PI to manually abstract into
    - I've done this before, and it worked ... with some caveats
    - Fewer opportunities for data validation
    - Potential for formatting errors, data deletion, etc.

---

# Potential solutions

<br>

<ol>

## <li>Change the .navy[**SQL**] data itself</li>

## <li>Pull, clean, and send .forest[**CSV**]</li>

## <li>Pull, clean, and set up .cardinal[**REDCap**]</li>

</ol>&nbsp;

*among other solutions...*

???

  - R/REDCap API 
    - Spoiler alert: this ended up being by solution, at least for now
    - Instead of hashing it out now, I'm going to spend most of this presentation explaining:
      - why this seems like the best solution given the circumstances
      - Its pros and cons
      - And best practices for using this approach in research with clinical data

---

<img src="images/redcap.png" height=80px style="margin:0 0 0 -10px">

<h3 style="margin: -10px 0 0px -2px">
.cardinal[R]esearch .cardinal[E]lectronic .cardinal[D]ata .cardinal[Cap]ture
</h3>

???

First, I wanted to VERY briefly go over REDCap itself. Many of you are likely familiar with it, but I wanted to describe some of its features that are relevant to what I'll be talking about today.

REDCap is a secure web application for building and managing online databases. It's a platform that allows researchers to enter data via an easy-to-use interface.

--

<center><img src="images/redcap-window.png" height=500px></center>

???

Here's what a REDCap window looks like if you're using Cornell's REDCap portal. 

The use-cases where REDCap shines aren't those involving solely data storage but rather where integrated data collection, storage, and collaboration are needed. It has a ton of features enabling data security, validation, and customization, so to me, it seems REDCap's primary benefit over something like shared CSV files is **controlled modifiability**. 

Most of the terms I'll use today will probably be familiar to those who work with data, but REDCap has some special language that I'll dive into very briefly here. 

The first is what REDCap calls a data dictionary. 

--

<div style="position: absolute; top: 345px; left: 250px; width:55px;height:15px;border:4px solid #BC2B35;"></div>

???

This term is probably familiar to most of you, but in REDCap's specific context, the dictionary serves both as a list of project variables (or "data fields") and their REDCap-specific attributes. Notably, you can't put data into a REDCap until you've specified its dictionary. 

The second term is what REDCap refers to as instruments. A REDCap dictionary creates the organizational instruments in which data will be collected and stored. 

--

<div style="position: absolute; top: 533px; left: 430px; width:140px;height:20px;border:4px solid #BC2B35;"></div>

???

In other words, instruments are groups of variables housed in a form -- for example, in this window, you see Demographics, Diagnosis History, Vitals, and Lab Results, each of which contains a collection of variables with a common theme.

It's not a perfect analogy, but I like to think of instruments as similar to SQL tables, in that they each contain a number of columns grouped with a common purpose.

As we'll see here in a bit, there are at least two ways I can interact with REDCap: via this web portal, or via the REDCap API. I've seen a ton of benefit from incorporating the latter approach into my workflow.

---

class: center, middle

## Working with the REDCap API
### *via* .cardinal[.code[**REDCapR**]]

???

One of the main reasons I chose this approach was that I could keep all of my work in R. I didn't need to do as much switching between the REDCap online interface, because everything can be contained in R scripts -- from pulling the SQL data to cleaning and pushing data to REDCap.

And while there are some incredible packages out there to deal with APIs in R -- httr, curl, and others -- REDCapR was an easy, out-of-the-box solution to linking R and REDCap via the API.

---

class: split-two

# Workflow


.pull-left[
<ol style="line-height:62px;">

## <li> Pull</li> 

## <li> Clean</li> 

## <li> Push</li> 

## <li> Abstract</li> 

</ol>.
]

--

.pull-right[
<ul style="list-style-type:none; line-height:80px;">
<li><img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"></li>
<li><img src="images/rlogo.svg" height=65px style="opacity:0; margin:-1px 5px 5px 15px"></li>
<li><img src="images/redcaprlogo.png" height=65px style="opacity:0; margin:-1px 5px 5px 20px"></li>
<li><img src="images/redcap.png" height=65px style="opacity:0; margin:-1px 5px 5px 15px"></li>
</ul>
]

???

In using R and the REDCap API, my workflow is generally this:

  - Pull data from a SQL backend (often integrating other sources, as well)
    - This isn't terribly relevant here, but many of you are probably using these same backend sources, so it's more to give context to workflows that may already exist for you
    - I usually use packages like DBI, dbmi, and dbplyr here, but I could give an entire separate talk on those

---

class: split-two

# Workflow


.pull-left[
<ol style="line-height:62px;">

## <li> Pull</li> 

## <li> Clean</li> 

## <li> Push</li> 

## <li> Abstract</li> 

</ol>.
]

.pull-right[
<ul style="list-style-type:none; line-height:80px;">
<li><img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"></li>
<li><img src="images/rlogo.svg" height=65px style="margin:-1px 5px 5px 15px"></li>
<li><img src="images/redcaprlogo.png" height=65px style="opacity:0; margin:-1px 5px 5px 20px"></li>
<li><img src="images/redcap.png" height=65px style="opacity:0; margin:-1px 5px 5px 15px"></li>
</ul>
]

???

  - Clean the data in a series of R scripts

---

class: split-two

# Workflow


.pull-left[
<ol style="line-height:62px;">

## <li> Pull</li> 

## <li> Clean</li> 

## <li> Push</li> 

## <li> Abstract</li> 

</ol>.
]

.pull-right[
<ul style="list-style-type:none; line-height:80px;">
<li><img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"></li>
<li><img src="images/rlogo.svg" height=65px style="margin:-1px 5px 5px 15px"></li>
<li><img src="images/redcaprlogo.png" height=65px style="margin:-1px 5px 5px 20px"></li>
<li><img src="images/redcap.png" height=65px style="opacity:0; margin:-1px 5px 5px 15px"></li>
</ul>
]

???

  - Push the data to REDCap using REDCapR, the R package I mentioned earlier

---

class: split-two

# Workflow


.pull-left[
<ol style="line-height:62px;">

## <li> Pull</li> 

## <li> Clean</li> 

## <li> Push</li> 

## <li> Abstract</li> 

</ol>.
]

.pull-right[
<ul style="list-style-type:none; line-height:80px;">
<li><img src="images/db.png" height=65px style="margin:10px 5px 5px 5px"></li>
<li><img src="images/rlogo.svg" height=65px style="margin:-1px 5px 5px 15px"></li>
<li><img src="images/redcaprlogo.png" height=65px style="margin:-1px 5px 5px 20px"></li>
<li><img src="images/redcap.png" height=65px style="margin:-1px 5px 5px 15px"></li>
</ul>
]

???

  - And then allow the PI to manually-abstract whatever data needs to be added via the REDCap online interface

... but what I'm really going to focus on today is ...

---

class: split-two

# Workflow


.pull-left[
<ol style="line-height:62px;">

## .grey2[<li> Pull</li>]

## .grey2[<li> Clean</li>]

## <li> Push</li> 

## .grey2[<li> Abstract</li>]

</ol>.
]

.pull-right[
<ul style="list-style-type:none; line-height:80px;">
<li><img src="images/db.png" height=65px style="opacity:0.1; margin:10px 5px 5px 5px"></li>
<li><img src="images/rlogo.svg" height=65px style="opacity:0.1; margin:-1px 5px 5px 15px"></li>
<li><img src="images/redcaprlogo.png" height=65px style="margin:-1px 5px 5px 20px"></li>
<li><img src="images/redcap.png" height=65px style="opacity:0.1; margin:-1px 5px 5px 15px"></li>
]

???

... using the REDCapR package to ease your interactions with the REDCap API via R. This mostly entails this "push" step, but the "abstract" step will sneak in here a bit.

---

<img src="images/redcapr-window.png">

???

So -- this is REDCapR. You can download it on CRAN

---

# .cardinal[.code[REDCapR]] Setup

???

It requires a tiny bit of setup as an interface between R and REDCap.

--

<br> 

## 1. Request a .cardinal[REDCap API token] 

<br>

Store your token in secure spot accessible by .code[R] (e.g. using .code[keyring]).

???

I won't go through this in too much detail, since the purpose of this presentation is more to make you aware of these features, but I'll mention the steps briefly.

Whether you're using a new or existing REDCap database, you'll need to request an API token, which usually doesn't take more than a day to be administered.

---

# .cardinal[.code[REDCapR]] Setup

<br> 
## 2. Ensure .golden[read/write] privileges

<br>

API privileges should include **API Export** and **API Import/Update**.

???

After you've been assigned a token, you'll also need to make sure you have the proper privileges on your REDCap repository. These user privileges are also useful for protecting your data from being accidentally edited by you or others.

---

# The Basics

<h3 style="margin: -10px 0 30px -10px">
Get data from an existing .cardinal[REDCap]
</h3>

--

```{r, eval = F}

# setup ------------------------------------------------------------

library(REDCapR)

uri <- "https://redcap.ctsc.weill.cornell.edu/redcap_protocols/api/"
token <- "9A81268476645C4E5F03428B8AC3AA7B"  # not real; store elsewhere!

```

???

So - maybe the most useful thing that anyone can do, even if you're not going to program an entire REDCap database in R, is to pull data using the REDCapR package.

First, assign your uri (which should be the same across Cornell REDCap repos) and token. And again, I usually store my token in a secure spot, but I'm showing it here for illustration.

---

# The Basics

<h3 style="margin: -10px 0 30px -10px">
Get data from an existing .cardinal[REDCap]
</h3>

```{r, eval = F}

# setup ------------------------------------------------------------

library(REDCapR)

uri <- "https://redcap.ctsc.weill.cornell.edu/redcap_protocols/api/"
token <- "9A81268476645C4E5F03428B8AC3AA7B"  # not real; store elsewhere!

# pull -------------------------------------------------------------

pull <- `redcap_read`(redcap_uri = uri,
                    token = token)

data <- pull$data

```

???

Next, you'll use REDCapR's redcap_read() function to pull data. It returns a variety of API-related data, but what we're really interested in is the repository data. You can pull that by subsetting the data element from the REDCap pull.

---

# The Basics

<h3 style="margin: -10px 0 30px -10px">
Get .bold[meta]data from an existing .cardinal[REDCap]
</h3>

--

```{r, eval = F}

# pull -------------------------------------------------------------

metadata <- `redcap_metadata_read`(redcap_uri = uri,
                                 token = token)

dictionary <- metadata$data

```

???

Metadata, which includes your data dictionary, is also something useful you can pull from REDCap via the API. Just use the redcap_metadata_read function, from which you'll again subset the data element to get the dictionary. The dictionary is pulled as a dataframe that contains the field names, their types, and other useful info.

---

# The Basics

<h3 style="margin: -10px 0 30px -10px">
Pushing things to .cardinal[REDCap]: your .bold[dictionary]
</h3>

???

Pushing data to REDCap via the API requires a little bit of learning, both about REDCap formats and using an API, neither of which I was familiar with. However, if this sounds like something that could be useful in your work, it could be worthwhile.

First, you'll need to define your data dictionary. As I mentioned, REDCap won't accept data without a dictionary in place first, which serves as a receiving template for your incoming data. You can design the dictionary on the online REDCap interface or programmatically in your R pipeline. I won't cover how to do so here, but if you'll be making lots of iterative changes or defining hundreds of variables, it might be worth doing programmatically.

--

```{r, eval = F}

# dictionary -------------------------------------------------------

 `redcap_metadata_write`(ds = my_dictionary,
                       redcap_uri = uri,
                       token = token)
```

???

You can push your created dictionary via the API using the redcap_metadata_write function. Your dictionary needs to be a specifically-formatted dataframe. The programmatic dictionary format is relatively simple but a bit too in-the-weeds for this presentation, so I'm happy to field any questions after the presentation or later on if you're interested.

---

# The Basics

<h3 style="margin: -10px 0 30px -10px">
Pushing things to .cardinal[REDCap]: your .bold[data]
</h3>

???

Once you have a correctly-formatted dictionary established in REDCap, you can push data to REDCap using the ...

--

```{r, eval = F}
# data -------------------------------------------------------------

 `redcap_write`(ds_to_write = df,
              redcap_uri = uri,
              token = token)

```

???

redcap_write function. I spend a lot of my time querying and cleaning data from SQL backends, and this function is incredibly useful to push data directly to REDCap repositories.

As with dictionaries, these dataframes need to be formatted specifically, especially if you're working in a REDCap project with longitudinal data. 

---

<h1 style="margin: 60px 0 50px 0">
More Advanced
</h1>

<h3 style="margin: -10px 0 30px -10px">
Updating existing data on .cardinal[REDCap]
</h3>

???

A little more advanced is actually updating existing data on a REDCap repository. Let's say you're just pushing SQL data at this point -- no manual abstraction has occurred.  However, you realize the SQL data needs a few edits.

There are several ways to accomplish this. One way I've done it is:

--

<ol>
  <li spacing="compact">&ensp; Pull existing data</li>

```{r, eval = F}

old_data <- `redcap_read`(uri, token)

```
???
  - Pull your existing data from REDCap, so that you have your current, correctly-formatted data to work from.

--
  <li>&ensp; Modify data in R pipeline (save this code!)</li>
  
```{r, eval = F}

new_data <- old_data %>% 
  mutate(new_col = ...,                         # modify dictionary
         existing_col = f(existing_col)) %>%    # no need
  add_row(...)                                  # no need

```
???
  - Modify your data using an R script. Be sure to save this code and incorporate it into your pipeline for reproducibility!
  
--
  <li>&ensp; Push new data (and dictionary, if needed)
  
```{r, eval = F}

 `redcap_write`(new_data, uri, token)

```
???
  - Then, push the edited data back to your REDCap. If you've added new columns, you may need to push a new dictionary before you push new data. With new rows and modifications to existing columns, you don't need to push a new dictionary.

---

# More Advanced

<h3 style="margin: -10px 0 30px -10px">
More .golden[API] stuff in R (.code[httr], .code[curl])
</h3>

???

So, here's an even more advanced use-case if you really want to tinker with your REDCap database. You can do a lot of things with the REDCap API directly that REDCapR doesn't have functions for. 

--
```{r, eval = F}

# project attributes -----------------------------------------------

formData <- list("token" = token,
                  content = 'project',
                  format = 'csv',
                  returnFormat = 'json')
response <- `httr::POST`(url, body = formData, encode = "form")
result <- httr::content(response)

```

???

This code is shown as an example, but it pulls project attributes from REDCap, which is useful for seeing whether a project is longitudinal, when it was last updated, and so on. You can also edit these attributes via the API.

--

*REDCap's .cardinal[**API playground**] is helpful here!

???

REDCap has an API playground that will walk you through different API functions and the R code needed to accomplish them. R packages httr and curl are most commonly used to deal with APIs.

---

# Use-cases
<br>
???
So with all of this in mind, what are some uses cases here?
--

### Mix programmatic and .cardinal[abstracted] data
???
The first is what I've been primarily concerned with. A PI needs to combine data from a backend server with data that can only be manually-abstracted. Instead of playing the game where we send each other a million CSV files, this has increased reproducbility a hundredfold for those projects.
--

### Long-term .forest[data sharing] with a team
???
Perhaps a simpler use-case is long-term data sharing with a team of researchers. Especially during COVID, cohorts are being created and modified weekly; if these data are stored and updated in REDCap via a reproducible pipeline, it'll reduce the chance of merge errors -- and you'll have fewer dated (or indistinguishable) CSV files in your data folder.
--

### If nothing else: .golden[API] convenience functions!
???
And, if nothing else - use the API in your pipelines to pull and catalog data from your existing REDCap repositories! One neat trick is to designate which columns are PHI, then easily pull a deidentified dataset if needed.

---

# Limitations `r emo::ji("sad_but_relieved_face")`
<br>
???
As I've mentioned, you have to take a lot of caution in using this approach. As such, there are some limitations here.
--

### Easy to .golden[mess things up]
???
First and most importantly, it's really easy to overwrite your REDCap, whether parts of it or the whole thing. I've started using cron to pull automatic data backups, and I've created functions to automatically save a backup anytime I update the REDCap, but it's still terrifing how easy it is to push a mistake and wipe your data.
--

### Pushed vs. .forest[abstracted] data
???
Secondly -- this is a pretty important note -- once someone starts manually abstracting into the REDCap frontend, youâ€™re stuck with the source data you've pushed from the backend. In my experience, there was just no simple way to, let's say, refresh your SQL source data after manual abstractions have occurred, since there aren't advanced difftools and mergetools that would allow you to distinguish which edits came from where. Thus, if you pushed new SQL data from the backend, it would erase all frontend manual edits.
--

### Particular .navy[object formatting] for RC API
???
The formatting of data and metadata uploaded via REDCap's API can be somewhat tricky. The peculiarities seem trivial until you need to produce pipelines for hundreds of variables, so I just have to write, commment, and debug API code carefully.
--

### .cardinal[REDCap] dev vs. prod status
???
Lastly, REDCap distinguishes between projects in development vs. production status, with the main difference being that production status makes a project harder to edit. Some REDCapR functions are limited to development projects due to their destructive nature, such as changing the dictionary. However, if proper caution is taken, I think the benefits outweigh the risks.

---

# Best .golden[(?)] practices
<br>
???
So -- some of my best practices so far! The question mark is there because I have no idea what best practices actually look like here. This has been a very iterative process, and I look forward to someone telling me a better way to approach anything I'm doing here.
--

### REDCap user rights `r emo::ji("check")`
???
As I've mentioned before, use REDCap user rights to your advantage! I change these frequently to make sure my colleagues and I aren't accidentally changing the data at a critical stage of data abstraction. 
--

### Regular (automated!) **backups** `r emo::ji("arrows_counterclockwise")`
???
Another thing I've found is that regular backups are GREAT, even if just for peace of mind. As I mentioned, I use cron on my MacBook to automatically run an R script that saves a backup of my REDCap repositories once a week. The repositories I currently work with are pretty small, but if you're looking at millions of rows, REDCap probably isn't the most efficient solution for you anyway.
--

### **Test**/**sandbox** REDCap repositories `r emo::ji("construction_worker_man")`
???
Another in the peace-of-mind category is a test REDCap repository. Before I change the dictionary or push new data to a PI-facing REDCap, I'll copy the production REDCap to a test REDCap and implement my changes there. This is a good thing, because usually my changes somehow break the database. If you have an exising REDCap project, requesting another database for test purposes is easy and very highly recommended!
--

### Personal **helper** functions `r emo::ji("toolbox")`
???
Lastly, I know I'm speaking to the computing club when I say this -- create helper functions on top of packages like REDCapR! Something I've learned in every aspect of my programming, not just dealing with APIs, is that custom functions allow me to do less debugging and consider higher-level aspects of my projects and analyses. Time spent writing these functions pays off several fold. 

---
???

[some sort of slide that brings together the ideas of reproducibility and modifiability]

e.g. all of this has married the two ideas of repro and mod

I hope you've seen that mod from PI end of REDCap is useful, but using that as an excuse to abandon reproducibility isn't necessary

---
class: center

.cardinal[**tl;dr**]
<br><br><br>
# MODIFIABILITY CAN BE USEFUL!

--

### *. . . in some circumstances*

--

### *. . . with proper precautions*


???

Summary slide

---

class: center, middle

# `r emo::ji("wave")`
# questions?

---

???

DRAFT

About REDCap API, REDCapR, and other solutions

  - Allows backend R pipeline feeding frontend REDCap (manually-abstractable)
  - (Also reproducible SQL pipeline from SQL to R (more on that in another presentation, maybe!))
  - Pros of REDCap:
    - If data simply cannot be programmatically created (complex, unwieldy, etc.) - individuals may choose to manually abstract
    - Easy-to-use, already-available platform that many PIs are familiar with (vs. SQL)
  - Cons of REDCap, esp. with using API:
    - For safety, need to ensure robust systems for data backup (not default/built in, but not terribly difficult)

---

???

DRAFT - probably near end

(My) best practices

  - Test REDCap repositories (can set up via request to REDCap Admin)
  - Automatic backups using cron
  - Helper functions
    - Metadata writing
    - Safe backup and export  
       - R: functions 
       - REDCap: limiting access (mine or PI's) to read-only













???

Outline:
  - Scenarios where modifiability can be **carefully** explored
  - Scenarios where modifiability is NOT okay (from irresponsible to malicious/misleading)
  - One solution: REDCapR API
    - Allows backend R pipeline feeding frontend REDCap (manually-abstractable)
    - (Also reproducible SQL pipeline from SQL to R (more on that in another presentation, maybe!))
    - Pros:
      - If data simply cannot be programmatically created (complex, unwieldy, etc.) - individuals may choose to manually abstract
      - Easy-to-use, already-available platform that many PIs are familiar with (vs. SQL)
    - Cons:
      - For safety, need to ensure robust systems for data backup (not default/built in, but not terribly difficult)
  - Things I've incorporated on top of REDCap API
    - Test REDCap repositories (can set up via request to REDCap Admin)
    - Automatic backups using cron
    - Helper functions
      - Metadata writing
      - Safe backup and export  
         - R: functions 
         - REDCap: limiting access (mine or PI's) to read-only
         
---
???
Other topics
  - REDCap's API Playground (screenshot of window) - gives R code to interact with API

---

class: center

.pull-left[
  ## Reproducible:
  
  .leftalign[
  
- Bullet 1 about reproducibility

- Another thing about reproducibility `r emo::ji("cowboy")`

- Ok, **one** last thing!
    
  ]
  
]

--

.pull-right[
  ## Modifiable:
  
  .leftalign[
  
- First things first about modifying data

- It's not good `r emo::ji("cry")`

- But sometimes it's necessary!

  ]
]
